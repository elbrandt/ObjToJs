#
# .obj to .js converter helper for UW Madison CS559
#
import itertools
import sys
import time
from datetime import datetime
import os
import re
import math
import argparse


def calc_vertex_normals(obj):
    obj['vn'] = []
    obj['fvn'] = []
    # for each triangle:
    # 1. calculate the normal, 2. enter it into the vn list, 3. add its index to the fvn list
    for idx in range(len(obj['fv']) // 3):
        p1 = obj['v'][obj['fv'][idx * 3 + 0]]
        p2 = obj['v'][obj['fv'][idx * 3 + 1]]
        p3 = obj['v'][obj['fv'][idx * 3 + 2]]

        v1 = [p2[i]-p1[i] for i in range(3)]
        v2 = [p3[i]-p1[i] for i in range(3)]

        # cross product:
        nx = v1[1]*v2[2]-v1[2]*v2[1]
        ny = v1[2]*v2[0]-v1[0]*v2[2]
        nz = v1[0]*v2[1]-v1[1]*v2[0]

        # normalize
        l = math.sqrt(nx*nx+ny*ny+nz*nz)
        vn = [nx / l, ny / l, nz / l] if l != 0 else [0.0, 0.0, 0.0]

        obj['vn'].append(vn)
        obj['fvn'] += [idx] * 3


def read_obj(file):
    # read an obj file and return a dictionary of v, vn, vt, and f elements
    def parsev(toks, qty):
        f = [float(t) for t in toks]
        while len(f) < qty:
            f.append(0.0)
        return f[0:qty]

    def splitn(str, s, n):
        ret = str.split(s)
        ret.extend([''] * n)
        return ret[0:n]

    def parsef(toks):
        sp = [splitn(s, '/', 3) for s in toks]
        v = [[None if (m is None or len(m) == 0) else int(m)-1 for m in n]
             for n in sp]
        # split an n-vertex polygon face into n-2 triangles
        ret = [[v[0], v[i-1], v[i]] for i in range(2, len(v))]
        return list(itertools.chain(*ret))

    with open(file, 'r') as fil:
        ret = {'v': [], 'vt': [], 'vn': [], 'fname': file}
        tris = []
        for line in fil:
            tok = line.split()
            if len(tok) >= 1:
                if tok[0] == 'v':
                    ret['v'].append(parsev(tok[1:], 3))
                if tok[0] == 'vt':
                    ret['vt'].append(parsev(tok[1:], 2))
                if tok[0] == 'vn':
                    ret['vn'].append(parsev(tok[1:], 3))
                if tok[0] == 'f':
                    tris += parsef(tok[1:])
    (ret['fv'], ret['fvt'], ret['fvn']) = zip(*tris)

    if len(ret['vn']) == 0 or None in ret['fvn']:
        print('NOTE: vertex normals not present in .obj file. Creating vertex normals.')
        calc_vertex_normals(ret)
    return ret


def gather_stats(obj):
    # gather statistics on the obj dictionary and return a stats dictionary
    stats = {}
    stats['# unique vertices'] = len(obj['v'])
    stats['# unique normals'] = len(obj['vn']) if None not in obj['vn'] else 0
    stats['# unique tex coords'] = len(
        obj['vt'])
    stats['# total vertices'] = len(obj['fv'])
    stats['# total normals'] = len(
        obj['fv']) if None not in obj['fvn'] else 0
    stats['# total tex coords'] = len(
        obj['fv']) if None not in obj['fvt'] else 0
    stats['# triangles'] = len(obj['fv']) // 3
    bb_min = [sys.float_info.max] * 3
    bb_max = [-sys.float_info.max] * 3
    for v in obj['v']:
        for i in range(3):
            bb_min[i] = min(bb_min[i], v[i])
            bb_max[i] = max(bb_max[i], v[i])
    stats['bb_min'] = bb_min
    stats['bb_max'] = bb_max
    return stats


def write_js(file, obj, model_name, stats):
    # write the obj dictionary to a javascript file

    def write_point_list(f, obj, nm, comment, var_name):
        if len(obj['f' + nm]) == 0:
            return

        f.write(f'// {comment}\n')
        f.write(f'{var_name} = new Float32Array([')
        num_verts = len(obj['f' + nm])
        for tidx in range(num_verts):
            vidx = obj['f' + nm][tidx]
            str = ', '.join([f'{i}' for i in obj[nm][vidx]])
            f.write(f" {str}")
            f.write(',' if tidx != num_verts - 1 else ']);\n\n')

    with open(file, 'w') as f:
        # write some comments at the beginning
        f.write(
            f"// Autogenerated with obj_to_js.py from {obj['fname']} at {datetime.now()} by {os.getlogin()}\n")
        f.write(
            f"// See https://github.com/elbrandt/ObjToJs for more info\n\n")
        for stat in stats:
            f.write(f'// {stat:20}: {stats[stat]}\n')
        f.write('\n')
        if len(obj['fv']) < (1 << 8):
            dtype = 'Uint8Array'
        elif len(obj['fv']) < (1 << 16):
            dtype = 'Uint16Array'
        else:
            dtype = 'Uint32Array'
        f.write('// {:20}: {}\n'.format('triangleIndices type', dtype))

        # the object
        f.write('// the object\n')
        f.write(f'var {model_name} = new Object();\n\n')

        # write bounding box properties
        f.write('// aligned bounding box extents\n')
        f.write(
            f"{model_name}.bboxMin = new Float32Array({stats['bb_min']});\n")
        f.write(
            f"{model_name}.bboxMax = new Float32Array({stats['bb_max']});\n\n")

        # Write triangle element index array
        f.write('// element index array\n')
        f.write(f'{model_name}.triangleIndices = new {dtype}([')
        assert (len(obj['fv']) % 3 == 0)
        num_tris = len(obj['fv']) // 3
        for t in range(num_tris):
            idxs = [t*3, t*3+1, t*3+2]
            str = ', '.join([f'{i}' for i in idxs])
            f.write(f" {str}")
            f.write(',' if t != num_tris - 1 else ']);\n\n')

        # write list of vertex positions
        write_point_list(f, obj, 'v', 'vertex positions',
                         f'{model_name}.vertexPos')

        # write list of vertex normals
        write_point_list(f, obj, 'vn', 'vertex normals',
                         f'{model_name}.vertexNormals')

        # write list of vertex texture coordinates (if we have them)
        if None not in obj['fvt'] and len(obj['vt']) > 0:
            write_point_list(
                f, obj, 'vt', 'vertex texture coordinates', f'{model_name}.vertexTextureCoords')
        else:
            print('\nNOTE: Skipping writing vertex texture coordinates to .js because they were not present (or incomplete) in .obj file.')


def obj_to_js(obj_fil_in, js_fil_out, model_name):
    print(
        f"\nTranlsating '{obj_fil_in}' to '{js_fil_out}'...")

    # give the model a default name if one is not provided
    if model_name is None or len(model_name) == 0:
        model_name = 'my_model'

    # ensure model_name is a valid javascript variable name, replace invalid chars with _
    # (note: doesn't check for javascript keywords)
    model_name_fix = re.sub(r'^[^a-zA-Z_$]|[^\w$]', '', model_name)
    if model_name_fix != model_name:
        model_name_fix = 'my_model' if len(
            model_name_fix) == 0 else model_name_fix
        print(
            f"\nNOTE: adjusting invalid model object name '{model_name}' to '{model_name_fix}'")
        model_name = model_name_fix

    # do it
    tm_start = time.time()
    obj_data = read_obj(obj_fil_in)
    stats = gather_stats(obj_data)
    write_js(js_fil_out, obj_data, model_name, stats)
    tm_finish = time.time()

    # print some final stats
    print('Stats:')
    for stat in stats:
        print(f'\t{stat:19}: {stats[stat]}')
    print(
        f"\nTranlsated '{obj_fil_in}' to model '{model_name}' in '{js_fil_out}' in {tm_finish-tm_start:0.3f} sec.")


def main():
    parser = argparse.ArgumentParser(
        prog='Obj to Js Converter',
        description='Helpful Utility for UW Madison CS559 webgl assignments',
        epilog='Additional info available at https://github.com/elbrandt/ObjToJs'
    )
    parser.add_argument('in_file', type=str,
                        help='input .obj file')
    parser.add_argument('out_file', type=str, nargs='?',
                        help='output .js file')
    parser.add_argument('model_name', type=str, nargs='?', default='my_model',
                        help='model name for variable in js')
    args = parser.parse_args()

    if not os.path.isfile(args.in_file):
        raise RuntimeError(f"input file {args['in_file']} not found")
    if args.out_file is None:
        args.out_file = os.path.splitext(args.in_file)[0] + '.js'
    obj_to_js(args.in_file, args.out_file, args.model_name)


if __name__ == '__main__':
    main()
